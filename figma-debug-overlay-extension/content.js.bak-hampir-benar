(function () {
  let overlay = null;
  let isEnabled = false;
  let currentItems = [];

  // --- Utility Functions ---

  function parseColor(color = '#000000', alpha = 0.1) {
    if (typeof color === 'string' && color.match(/^rgb|a/)) {
      return color.replace(/[\d.]+(?=\)$)/, alpha);
    }
    let hex = color.replace('#', '');
    if (hex.length === 3)
      hex = hex
        .split('')
        .map((x) => x + x)
        .join('');
    const r = parseInt(hex.substr(0, 2), 16) || 0;
    const g = parseInt(hex.substr(2, 2), 16) || 0;
    const b = parseInt(hex.substr(4, 2), 16) || 0;
    return `rgba(${r},${g},${b},${alpha})`;
  }

  function createOverlay() {
    if (overlay) return overlay;
    overlay = document.createElement('div');
    overlay.id = 'figma-debug-overlay';
    overlay.style.cssText = 'position:fixed;inset:0;pointer-events:none;z-index:2147483647;';
    document.body.appendChild(overlay);
    return overlay;
  }

  // --- Rendering Logic ---

  function renderLayout(item, isColumns = true) {
    const bg = parseColor(item.color || (isColumns ? '#ff0000' : '#0000ff'), item.opacity || 0.1);

    // 1. Tentukan Mode
    // Jika typeMode kosong, default ke stretch.
    const mode = item.typeMode || 'stretch';
    const isStretchMode = mode === 'stretch';

    const count = item.count || 12;
    const gutter = item.gutter ?? 20;
    const margin = item.margin ?? 0;
    const offset = item.offset ?? 0;

    // Fixed Size hanya dipakai jika BUKAN stretch
    const fixedSize = item.width ?? (isColumns ? 80 : 60);

    let maxWidth = item.maxWidth && !isNaN(item.maxWidth) && item.maxWidth > 0 ? item.maxWidth : null;

    // Safety: Jika mode stretch murni, cek margin
    if (isStretchMode && maxWidth && maxWidth <= margin * 2) {
      console.warn('Figma Overlay: MaxWidth too small');
      maxWidth = null;
    }

    // --- LOGIC ALIGNMENT ---
    let align = 'center';
    let startSpacing = 0;
    let endSpacing = 0;
    let translateOffset = 0;

    if (isStretchMode) {
      align = 'stretch';
      startSpacing = margin;
      endSpacing = margin;
    } else {
      // Mode Fixed (Left/Right/Center)
      if (mode === 'center') {
        align = 'center';
        translateOffset = offset;
      } else if (mode === 'left' || (!isColumns && mode === 'top')) {
        align = 'start';
        startSpacing = offset;
      } else if (mode === 'right' || (!isColumns && mode === 'bottom')) {
        align = 'end';
        endSpacing = offset;
      }
    }

    // --- PERBAIKAN KRUSIAL DI SINI ---
    // Kita tentukan template kolom secara eksplisit.
    // HANYA gunakan 1fr jika mode benar-benar 'stretch'.
    // Selain itu (left, right, center), WAJIB gunakan px.
    let templateStyle;
    if (isStretchMode) {
      templateStyle = `repeat(${count}, 1fr)`;
    } else {
      templateStyle = `repeat(${count}, ${fixedSize}px)`; // <--- INI KUNCINYA
    }

    // Hitung ukuran konten murni (pixel)
    const contentSize = count * fixedSize + (count > 1 ? (count - 1) * gutter : 0);

    // Logic Wrapper Size:
    // Jika Stretch atau ada MaxWidth, wrapper 100% (agar flexbox parent bisa ngatur posisi).
    // Jika Fixed murni tanpa MaxWidth, wrapper sesuai pixel konten.
    let wrapperSize = isStretchMode || maxWidth ? '100%' : `${contentSize}px`;

    // 1. CONTAINER PARENT (Flexbox untuk Alignment Global)
    const container = document.createElement('div');
    container.style.cssText = 'position:absolute;inset:0;pointer-events:none;display:flex;';

    // Tentukan Justify (Posisi Container Utama)
    let justifyVal;
    if (align === 'center') justifyVal = 'center';
    else if (align === 'start') justifyVal = 'flex-start';
    else if (align === 'end') justifyVal = 'flex-end';
    else justifyVal = 'center';

    if (isColumns) {
      container.style.justifyContent = justifyVal;
      container.style.alignItems = 'stretch';
    } else {
      // Rows
      container.style.justifyContent = maxWidth ? justifyVal : 'stretch';
      container.style.alignItems = justifyVal;
    }

    // 2. GRID WRAPPER
    const gridDiv = document.createElement('div');
    gridDiv.style.display = 'grid';

    // Terapkan Template yang sudah dihitung di atas
    gridDiv.style[isColumns ? 'gridTemplateColumns' : 'gridTemplateRows'] = templateStyle;
    gridDiv.style[isColumns ? 'columnGap' : 'rowGap'] = `${gutter}px`;

    gridDiv.style[isColumns ? 'width' : 'height'] = wrapperSize;
    gridDiv.style[isColumns ? 'height' : 'width'] = '100%';

    // Logic Max Width
    if (maxWidth) {
      gridDiv.style.maxWidth = `${maxWidth}px`;

      // TAMBAHAN PENTING:
      // Jika mode Fixed (Left/Right) tapi dibungkus MaxWidth lebar (100%),
      // kolom di dalamnya (yg sudah fix px) akan nempel kiri secara default.
      // Kita perlu align content grid-nya juga agar nempel kanan jika mode Right.
      if (!isStretchMode) {
        let gridJustify = 'start'; // default left
        if (mode === 'center') gridJustify = 'center';
        if (mode === 'right') gridJustify = 'end';

        gridDiv.style.justifyContent = gridJustify;
      }

      if (align === 'center') {
        gridDiv.style.marginInline = 'auto';
      }
    }

    // SPACING (Margin/Offset)
    if (isStretchMode) {
      gridDiv.style[isColumns ? 'paddingInline' : 'paddingBlock'] = `${startSpacing}px ${endSpacing}px`;
    } else {
      if (align === 'start') {
        gridDiv.style[isColumns ? 'marginLeft' : 'marginTop'] = `${startSpacing}px`;
      } else if (align === 'end') {
        gridDiv.style[isColumns ? 'marginRight' : 'marginBottom'] = `${endSpacing}px`;
      } else if (align === 'center' && translateOffset !== 0) {
        const axis = isColumns ? 'X' : 'Y';
        gridDiv.style.transform = `translate${axis}(${translateOffset}px)`;
      }
    }

    for (let i = 0; i < count; i++) {
      const cell = document.createElement('div');
      cell.style.background = bg;
      gridDiv.appendChild(cell);
    }

    container.appendChild(gridDiv);
    return container;
  }

  function renderLayout(item, isColumns = true) {
    const bg = parseColor(item.color || (isColumns ? '#ff0000' : '#0000ff'), item.opacity || 0.1);

    // Cek apakah mode aslinya adalah Stretch
    const isStretchMode = item.typeMode === 'stretch' || !item.typeMode;

    const count = item.count || 12;
    const gutter = item.gutter ?? 20;
    const margin = item.margin ?? 0;
    const offset = item.offset ?? 0;

    // Lebar fixed per kolom (jika mode Left/Right/Center)
    const fixedSize = item.width ?? (isColumns ? 80 : 60);
    const typeMode = item.typeMode || 'stretch';

    let maxWidth = item.maxWidth && !isNaN(item.maxWidth) && item.maxWidth > 0 ? item.maxWidth : null;

    // Safety: Jika mode stretch murni (tanpa maxwidth), pastikan margin masuk akal
    if (isStretchMode && maxWidth && maxWidth <= margin * 2) {
      console.warn('Figma Overlay: MaxWidth too small');
      maxWidth = null;
    }

    // --- LOGIC ALIGNMENT & SPACING ---
    let align = 'center'; // start | end | center | stretch
    let startSpacing = 0;
    let endSpacing = 0;
    let translateOffset = 0;

    if (isStretchMode) {
      align = 'stretch';
      startSpacing = margin;
      endSpacing = margin;
    } else {
      // Mode Fixed (Left/Right/Center)
      if (typeMode === 'center') {
        align = 'center';
        translateOffset = offset;
      } else if (typeMode === 'left' || (!isColumns && typeMode === 'top')) {
        align = 'start';
        startSpacing = offset;
      } else if (typeMode === 'right' || (!isColumns && typeMode === 'bottom')) {
        align = 'end';
        endSpacing = offset; // Offset dari kanan/bawah
      }
    }

    // --- PERBAIKAN UTAMA DI SINI ---
    // Jika ada MaxWidth pada Columns, isi grid HARUS menjadi fluid (1fr)
    // agar bisa mengecil mengikuti container.
    // Jika Rows, biarkan tetap fixed height (biasanya untuk baseline grid).
    const forceFluid = isColumns && maxWidth !== null;
    const shouldUseFraction = isStretchMode || forceFluid;

    // Hitung ukuran wrapper
    // Jika fluid/maxwidth aktif, wrapper ambil 100% dari container parent (yang nanti di-limit max-width)
    // Jika fixed murni (tanpa maxwidth), wrapper sesuai total pixel
    const contentSize = count * fixedSize + (count > 1 ? (count - 1) * gutter : 0);
    let wrapperSize = shouldUseFraction ? '100%' : `${contentSize}px`;

    // 1. CONTAINER PARENT (Flexbox untuk Positioning Left/Right/Center)
    const container = document.createElement('div');
    container.style.cssText = 'position:absolute;inset:0;pointer-events:none;display:flex;';

    // Tentukan Justify Content (Posisi Horizontal)
    let justifyVal;
    if (align === 'center') justifyVal = 'center';
    else if (align === 'start')
      justifyVal = 'flex-start'; // Kiri / Atas
    else if (align === 'end')
      justifyVal = 'flex-end'; // Kanan / Bawah
    else justifyVal = 'center';

    if (isColumns) {
      container.style.justifyContent = justifyVal;
      container.style.alignItems = 'stretch';
    } else {
      // Untuk Rows: Jika ada maxWidth, kita atur posisi horizontalnya (Left/Right/Center)
      // Jika tidak ada maxWidth, row selalu stretch horizontal
      container.style.justifyContent = maxWidth ? justifyVal : 'stretch';
      container.style.alignItems = justifyVal; // Posisi vertikal rows (Top/Bottom)
    }

    // 2. GRID WRAPPER (CSS Grid)
    const gridDiv = document.createElement('div');
    gridDiv.style.display = 'grid';

    // Terapkan 1fr jika fluid/maxwidth, atau pixel jika fixed pure
    gridDiv.style[isColumns ? 'gridTemplateColumns' : 'gridTemplateRows'] = shouldUseFraction
      ? `repeat(${count}, 1fr)`
      : `repeat(${count}, ${fixedSize}px)`;

    gridDiv.style[isColumns ? 'columnGap' : 'rowGap'] = `${gutter}px`;

    gridDiv.style[isColumns ? 'width' : 'height'] = wrapperSize;
    gridDiv.style[isColumns ? 'height' : 'width'] = '100%';

    // Terapkan Max Width pada Grid Wrapper
    if (maxWidth) {
      gridDiv.style.maxWidth = `${maxWidth}px`;
      gridDiv.style.width = '100%';

      // Khusus jika Align Center, pastikan margin auto agar grid tetap di tengah container max-width
      if (align === 'center') {
        gridDiv.style.marginInline = 'auto';
      }
    }

    // APLIKASI SPACING (Offset / Margin)
    if (isStretchMode) {
      gridDiv.style[isColumns ? 'paddingInline' : 'paddingBlock'] = `${startSpacing}px ${endSpacing}px`;
    } else {
      // Mode Fixed (Left/Right) dengan Offset
      if (align === 'start') {
        gridDiv.style[isColumns ? 'marginLeft' : 'marginTop'] = `${startSpacing}px`;
      } else if (align === 'end') {
        gridDiv.style[isColumns ? 'marginRight' : 'marginBottom'] = `${endSpacing}px`; // Gunakan margin-right untuk align right
      } else if (align === 'center' && translateOffset !== 0) {
        const axis = isColumns ? 'X' : 'Y';
        gridDiv.style.transform = `translate${axis}(${translateOffset}px)`;
      }
    }

    // Render Cell
    for (let i = 0; i < count; i++) {
      const cell = document.createElement('div');
      cell.style.background = bg;
      gridDiv.appendChild(cell);
    }

    container.appendChild(gridDiv);
    return container;
  }

  function renderItem(item) {
    if (!item || !item.type) return null;
    if (item.visible === false) return null;

    if (item.type === 'grid') {
      item.size = item.count || item.size || 8;
      return renderGrid(item);
    }
    if (item.type === 'columns') return renderLayout(item, true);
    if (item.type === 'rows') return renderLayout(item, false);
    return null;
  }

  function renderAll() {
    createOverlay();
    overlay.innerHTML = '';
    if (!currentItems || currentItems.length === 0) return;

    currentItems.forEach((item) => {
      const el = renderItem(item);
      if (el) overlay.appendChild(el);
    });
  }

  function toggleOverlay() {
    isEnabled = !isEnabled;
    if (isEnabled) renderAll();
    else if (overlay) overlay.innerHTML = '';
  }

  // --- Initialization ---

  chrome.storage.sync.get('figmaOverlayData', (data) => {
    const store = data.figmaOverlayData;
    if (store && store.activeId && store.profiles[store.activeId]) {
      currentItems = store.profiles[store.activeId].items;
    } else {
      currentItems = [];
    }
  });

  document.addEventListener('keydown', (e) => {
    const tag = e.target.tagName.toUpperCase();
    if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;

    if (e.key.toLowerCase() === 'g' && !e.ctrlKey && !e.metaKey && !e.altKey) {
      e.preventDefault();
      toggleOverlay();
    }
  });

  chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    if (msg.action === 'apply') {
      currentItems = msg.items || [];
      if (msg.forceActive) isEnabled = true;
      if (isEnabled) renderAll();
      else if (overlay) overlay.innerHTML = '';
    } else if (msg.action === 'toggle') {
      toggleOverlay();
    }
    sendResponse({ status: 'ok' });
    return true;
  });
})();
